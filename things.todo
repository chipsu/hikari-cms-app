Next:
  1. Controllers & (REST) API
  2. Modules + Widgets & API
  3. Restructure library
  4. Rethink asset handling & building
  5. Composer
  6. Grid-admin 2.0
Library:
  General:
    ☐ Remove traits, use mixins.
    ✔ Use getProp, setProp, __get, __set for Components. @done (15-03-01 21:26)
    ☐ Less agressive caching for dev (check if dependencies have been modified).
    ☐ Organize namespace and class names (classes, actions & filters)
    ☐ Component contexts vs App!?
    ☐ dev.?.com -> grid with stuff using the cms
    ☐ demo.?.com -> demo cms
  Error handling:
    ☐ Output appropriate format (json, xml or html)
    ☐ Logging and all that
  Core:
    ☐ Component
      ✔ Mixins (behaviours) @done (15-03-01 21:26)
    ☐ Request
      ✔ Content parser @done (15-03-01 21:26)
      ☐ Headers
      ☐ HTTP-method override from post-param (so forms can use same controller as the REST-API)
        Not so sure about this, return to referer? What about API-keys? Generic HTTP-header override? _method=post&_returl=referer&_token=apikey
        Make it an option if implemented. Request::$httpPostHeaders = []
  Controller:
    ☐ Actions & $context & Reflection
    ☐ Rest
      ☐ Honor accept header
      ☐ Method filter
      ☐ Map to REST calls to index, create, read, update, delete
  Views:
    ☐ Code cleanup
      ✔ View as filter() @done (15-03-01 21:28)
      ☐ Fix namespaces
      ☐ Remove old code
    ☐ HTPL
      ☐ Should we really use this? Or maybe Twig?
      ☐ Fix argument parsing
      ☐ Fix string concat (use "..")
      ☐ JavaScript li
      ☐ Patch files?
  Forms:
    ☐ FormBuilder
    ☐ FormModels?
  Models:
    ☐ Move Mongo stuff to own ns
    ☐ Move generic stuff from CMS to core (models, validation)
    ☐ Use new Component interface for Models & Attributes.
    ☐ DataProvider interface (Feeds 2.0)
  Routing:
    ✔ URLRule http method & headers @done (15-06-30 21:46)
  Helpers/Widgets:
    ☐ HTML
      ☐ ActiveMenu using DataProvider
CMS:
  2.0:
    Nodes:
      ☐ Everything is a node
      ☐ A node can set a template that's used for list (set of resources) and read (single resource) actions, ie. Products and View product.
      ☐ Templates are inherited from parent nodes, they can be extended or replaced by child nodes.
    Templates:
      ☐ Grid layout containers
      ☐ Responsive
      ☐ Each area can be hidden or visible with media queries
      ☐ Templates always extend a root template (html code)
        node:
           name: "asdf"
           template: "default"
        child_node:
           name: "asdf/child"
           parent: ref(some_id)
           template: null
      ☐ Templates define widget areas (sidebar, top, content)
        default:
          top: [$logo, $cart]
          content: [$mainContent]
          bottom: [$footer]
        product-list:
          @extends default
          content: [$sidebar, $mainContent]
        product:
          @extends default
          content: [$mainContent, $relatedProducts, $addToWishlist]
    Widgets:
      ☐ Placed in a widget area for a template
      ☐ Responsive
      ☐ ListWidget: Lists all children or related resources (product list) - Properties: cols(mobile,tablet), pageSize etc
      ☐ CartWidget: Displays a shopping cart
    Design tool:
      ☐ Admins can use the grid tool to build layouts, we need a SASS & JS-editor (+maybe HTPL/HTML-template editor) so we can do everything in the browser.
      ☐ Integrate with browser-sync
  Admin:
    The admin interface uses the same controller as the client but different views
    ☐ Default views for all resources
    ☐ Client and admin user custom views
    ☐ Admin menu, specified in config or autogenerated (action function comments)?
    ☐ Dashboard
  Things:
    ☐ Inline-editor using hui-data & hui-data-view
      ☐ check what kind of object hui-data is (list or single entity) how? if self.has(hui-data-id) then single else list (assuming > * has data-id)
      ☐ for admins: display editor: add & edit items
      ☐ for all: allow refresh of item
    ☐ How do we set hui-data route?
  Base views & styling:
    ☐ Sane HTML structure and easy to override with app-css
      ☐ BEM (with class modifiers?)
      ☐ Reset: Little nesting, few variables & modifiers
  Model:
    ☐ Index & ensureIndex
    ☐ Model & input validation
    ☐ Translation
    ☐ Submodels & Attributes, one base interface?
  Core:
    ☐ ACL
    ☐ Auth
    ☐ Tagging (use category:tagname? tag = {category: "poo", name: "oop"})
    ☐ Categories & Hierarchy
    ☐ Dynamic model properties, class aliases & security
    ☐ Modules & Non-post-content controllers
      Like checkout, or are they just a special kind of Content? Heck, checkout could just be an Order view. So, /checkout => /order/edit/{active-order-id}
      We still need to organize controllers though, just use lib/ in cms? Like hikari-cms/lib/klarna-checkout.
      Does (maybe) require config merging, /checkout/klarna/ => loadModule('klarna') and redirect to klarnactrl.
    ☐ Menu content class
    ☐ Content controller?
      Some view, like checkout will need parameters that depend on the Content (payment options for Order).
      How do we get these params? Controller forward? From the Model? Or maybe a helper that's loaded into the controller and passed on to the view?
    ☐ Content class editor, is it a view? Maybe use controller as above.
    ☐ REST OPTIONS
  API
    ☐ Stuff
    ☐ Console (curl wrapper using the REST API?)
        Example: $ console init mysite.example.com/api
                         # auth if needed
                         $ console post product [data]
                         # if no data: attempts to fetch schema for product
                         #                   promts the user for input, example
                         $ name: Type name here
                         $ article_number: ...
                         # special key to submit instantly
  Future:
    ☐ Automagic binding of action parameters, like so:
      function someAction($a, $b, RouterInterface $router)
